import {
  require_maplibre_gl
} from "./chunk-QP5FYCEA.js";
import {
  Layer,
  useMap
} from "./chunk-RR6RTHDI.js";
import {
  Canvas,
  _roots,
  createPointerEvents,
  createPortal,
  createRoot,
  extend,
  useFrame,
  useThree
} from "./chunk-23OJSNTT.js";
import "./chunk-Q7ZIGZSP.js";
import {
  require_jsx_runtime
} from "./chunk-MJNCUEZK.js";
import {
  require_react_dom
} from "./chunk-HE4GKDYE.js";
import {
  require_react
} from "./chunk-UGC3UZ7L.js";
import {
  Euler,
  MathUtils,
  Matrix4,
  Quaternion,
  Scene,
  Vector3,
  three_module_exports
} from "./chunk-I64PBAE6.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-three-map/dist/maplibre/es/main2.mjs
var useMap2 = () => useThree((s) => {
  var _a;
  return (_a = s.r3m) == null ? void 0 : _a.map;
});

// node_modules/react-three-map/dist/maplibre/es/main3.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_maplibre_gl = __toESM(require_maplibre_gl(), 1);
var import_react10 = __toESM(require_react(), 1);

// node_modules/react-three-map/dist/maplibre/es/main12.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/react-three-map/dist/maplibre/es/main19.mjs
var quat = new Quaternion();
var euler = new Euler();
var pos = new Vector3();
var scale = new Vector3();
var m4 = new Matrix4();
function coordsToMatrix({
  longitude,
  latitude,
  altitude,
  fromLngLat: fromLngLat2
}) {
  const center = fromLngLat2([longitude, latitude], altitude);
  const scaleUnit = center.meterInMercatorCoordinateUnits();
  pos.set(center.x, center.y, center.z || 0);
  scale.set(scaleUnit, -scaleUnit, scaleUnit);
  quat.setFromEuler(euler.set(-Math.PI * 0.5, 0, 0));
  return m4.compose(pos, quat, scale).toArray();
}

// node_modules/react-three-map/dist/maplibre/es/main12.mjs
function useCoordsToMatrix({ latitude, longitude, altitude, fromLngLat: fromLngLat2 }) {
  const m42 = (0, import_react.useMemo)(() => coordsToMatrix({
    latitude,
    longitude,
    altitude,
    fromLngLat: fromLngLat2
  }), [latitude, longitude, altitude, fromLngLat2]);
  return m42;
}

// node_modules/react-three-map/dist/maplibre/es/main11.mjs
var originMx = new Matrix4();
var projByView = new Matrix4();
var projByViewInv = new Matrix4();
var fwd = new Vector3();
function syncCamera(camera, origin, mapCamMx) {
  projByView.fromArray(mapCamMx).multiply(originMx.fromArray(origin));
  projByViewInv.copy(projByView).invert();
  updateCamera(camera, projByViewInv);
  camera.updateMatrix();
  camera.updateMatrixWorld(true);
  camera.projectionMatrix.copy(camera.matrix).premultiply(projByView);
  camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
  camera.far = calculateFar(
    camera.matrix.elements[10],
    camera.matrix.elements[14],
    camera.near
  );
  camera.userData.projByView = projByView.toArray();
  camera.userData.projByViewInv = projByViewInv.toArray();
}
var updateCamera = (target, projByViewInv2) => {
  target.position.setScalar(0).applyMatrix4(projByViewInv2);
  target.up.set(0, -1, 0).applyMatrix4(projByViewInv2).negate().add(target.position).normalize();
  fwd.set(0, 0, 1).applyMatrix4(projByViewInv2);
  target.lookAt(fwd);
};
function calculateFar(c, d, near) {
  const numerator = d * (c - 1);
  const denominator = c * near + near;
  const far = numerator / denominator;
  return far;
}

// node_modules/react-three-map/dist/maplibre/es/main10.mjs
var import_react2 = __toESM(require_react(), 1);
var useFunction = (callback) => {
  const callbackRef = (0, import_react2.useRef)(callback);
  callbackRef.current = callback;
  return (0, import_react2.useCallback)((...args) => {
    return callbackRef.current(...args);
  }, []);
};

// node_modules/react-three-map/dist/maplibre/es/main16.mjs
function useRender({
  map,
  origin,
  useThree: useThree2,
  frameloop,
  r3m
}) {
  const render = useFunction((_gl, projViewMx) => {
    const pVMx = "defaultProjectionData" in projViewMx ? Object.values(projViewMx.defaultProjectionData.mainMatrix) : projViewMx;
    r3m.viewProjMx.splice(0, 16, ...pVMx);
    const state = useThree2.getState();
    const camera = state.camera;
    const { gl, advance } = state;
    syncCamera(camera, origin, pVMx);
    gl.resetState();
    advance(Date.now() * 1e-3, true);
    if (!frameloop || frameloop === "always")
      map.triggerRepaint();
  });
  return render;
}

// node_modules/react-three-map/dist/maplibre/es/main17.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-three-map/dist/maplibre/es/main20.mjs
var projViewInv = new Matrix4();
var events = (store) => {
  const originalEvents = createPointerEvents(store);
  return {
    ...originalEvents,
    connect: (target) => {
      if (!originalEvents.connect)
        return;
      originalEvents.connect(target.parentElement);
    },
    compute: (event, state) => {
      state.pointer.x = event.offsetX / state.size.width * 2 - 1;
      state.pointer.y = 1 - event.offsetY / state.size.height * 2;
      if (state.camera.userData.projByViewInv)
        projViewInv.fromArray(state.camera.userData.projByViewInv);
      state.raycaster.camera = state.camera;
      state.raycaster.ray.origin.setScalar(0).applyMatrix4(projViewInv);
      state.raycaster.ray.direction.set(state.pointer.x, state.pointer.y, 1).applyMatrix4(projViewInv).sub(state.raycaster.ray.origin).normalize();
    }
  };
};

// node_modules/react-three-map/dist/maplibre/es/main15.mjs
var import_react3 = __toESM(require_react(), 1);
function useCoords() {
  const coords = useThree((s) => s.coords);
  return coords;
}
function useSetCoords({ longitude, latitude, altitude }) {
  const canvas = useThree((s) => s.gl.domElement);
  (0, import_react3.useMemo)(() => {
    const store = _roots.get(canvas).store;
    const coords = { longitude, latitude, altitude };
    setCoords(store, coords);
  }, [longitude, latitude, altitude]);
}
function useSetRootCoords(store, {
  longitude,
  latitude,
  altitude
}) {
  (0, import_react3.useMemo)(() => {
    setCoords(store, { longitude, latitude, altitude });
  }, [longitude, latitude, altitude]);
}
function setCoords(store, coords) {
  store.setState({ coords });
}

// node_modules/react-three-map/dist/maplibre/es/main13.mjs
var import_react4 = __toESM(require_react(), 1);
function useR3M() {
  const r3m = useThree((s) => s.r3m);
  return r3m;
}
function useInitR3M(props) {
  const canvas = useThree((s) => s.gl.domElement);
  (0, import_react4.useState)(() => {
    const store = _roots.get(canvas).store;
    initR3M({ ...props, store });
  });
}
function initR3M({ store, ...props }) {
  const viewProjMx = new Matrix4().identity().toArray();
  const r3m = { ...props, viewProjMx };
  store.setState({ r3m });
  return r3m;
}

// node_modules/react-three-map/dist/maplibre/es/main17.mjs
function useRoot(fromLngLat2, map, { frameloop, longitude, latitude, altitude, ...props }) {
  const [{ root, useThree: useThree2, canvas, r3m }] = (0, import_react5.useState)(() => {
    const canvas2 = map.getCanvas();
    const gl = canvas2.getContext("webgl2") || canvas2.getContext("webgl");
    const root2 = createRoot(canvas2);
    root2.configure({
      dpr: window.devicePixelRatio,
      events,
      ...props,
      frameloop: "never",
      gl: {
        context: gl,
        autoClear: false,
        antialias: true,
        ...props == null ? void 0 : props.gl
      },
      onCreated: (state) => {
        state.gl.forceContextLoss = () => {
        };
      },
      camera: {
        matrixAutoUpdate: false,
        near: 0
      },
      size: {
        width: canvas2.clientWidth,
        height: canvas2.clientHeight,
        top: canvas2.offsetTop,
        left: canvas2.offsetLeft,
        updateStyle: false,
        ...props == null ? void 0 : props.size
      }
    });
    const store = _roots.get(canvas2).store;
    const r3m2 = initR3M({ map, fromLngLat: fromLngLat2, store });
    setCoords(store, { longitude, latitude, altitude });
    if (frameloop === "demand") {
      store.setState({
        frameloop,
        invalidate: () => {
          map.triggerRepaint();
        }
      });
    }
    return { root: root2, useThree: store, map, canvas: canvas2, r3m: r3m2 };
  });
  const onResize = useFunction(() => {
    const { setDpr, setSize } = useThree2.getState();
    setDpr(window.devicePixelRatio);
    setSize(
      canvas.clientWidth,
      canvas.clientHeight,
      false,
      canvas.offsetTop,
      canvas.offsetLeft
    );
  });
  const onRemove = useFunction(() => {
    root.unmount();
  });
  useSetRootCoords(useThree2, { longitude, latitude, altitude });
  (0, import_react5.useEffect)(() => {
    if (frameloop !== "demand")
      return;
    const setState = useThree2.setState;
    const { invalidate } = useThree2.getState();
    setState({
      frameloop,
      invalidate: () => {
        map.triggerRepaint();
      }
    });
    return () => {
      setState({ frameloop: "never", invalidate });
    };
  }, [frameloop]);
  (0, import_react5.useEffect)(() => {
    map.on("resize", onResize);
    return () => {
      map.off("resize", onResize);
    };
  }, []);
  (0, import_react5.useEffect)(() => {
    root.render((0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: props.children }));
  }, [props.children]);
  return { onRemove, useThree: useThree2, r3m };
}

// node_modules/react-three-map/dist/maplibre/es/main8.mjs
function useCanvasInLayer(props, fromLngLat2, map) {
  const { latitude, longitude, altitude, frameloop } = props;
  const origin = useCoordsToMatrix({
    latitude,
    longitude,
    altitude,
    fromLngLat: fromLngLat2
  });
  const { onRemove, useThree: useThree2, r3m } = useRoot(fromLngLat2, map, props);
  const render = useRender({ origin, frameloop, useThree: useThree2, map, r3m });
  return {
    id: props.id,
    beforeId: props.beforeId,
    onRemove,
    render,
    type: "custom",
    renderingMode: "3d"
  };
}

// node_modules/react-three-map/dist/maplibre/es/main9.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/react-three-map/dist/maplibre/es/main18.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/react-three-map/dist/maplibre/es/main21.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var InitR3M = (0, import_react6.memo)(({
  longitude,
  latitude,
  altitude,
  ...props
}) => {
  useInitR3M(props);
  useSetCoords({ longitude, latitude, altitude });
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
});
InitR3M.displayName = "InitR3M";

// node_modules/react-three-map/dist/maplibre/es/main22.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var SyncCameraFC = (0, import_react7.memo)(({
  latitude,
  longitude,
  altitude = 0,
  setOnRender,
  manualRender,
  onReady,
  map
}) => {
  const mapCanvas = map.getCanvas();
  const r3m = useR3M();
  const camRef = (0, import_react7.useRef)(null);
  const camera = useThree((s) => s.camera);
  const gl = useThree((s) => s.gl);
  const threeCanvas = useThree((s) => s.gl.domElement);
  const scene = useThree((s) => s.scene);
  const advance = useThree((s) => s.advance);
  const setSize = useThree((s) => s.setSize);
  const set = useThree((s) => s.set);
  const origin = useCoordsToMatrix({ latitude, longitude, altitude, fromLngLat: r3m.fromLngLat });
  const ready = (0, import_react7.useRef)(false);
  const triggerRepaint = (0, import_react7.useMemo)(() => map.triggerRepaint, [map]);
  const mapPaintRequests = (0, import_react7.useRef)(0);
  const triggerRepaintOff = useFunction(() => {
    mapPaintRequests.current++;
  });
  useFrame(() => {
    syncCamera(camera, origin, r3m.viewProjMx);
    if (manualRender)
      gl.render(scene, camera);
    map.triggerRepaint = triggerRepaint;
    if (mapPaintRequests.current > 0) {
      mapPaintRequests.current = 0;
      map.triggerRepaint();
    }
  }, -Infinity);
  const onRender = useFunction((viewProjMx) => {
    map.triggerRepaint = triggerRepaintOff;
    if (threeCanvas.width !== mapCanvas.width || threeCanvas.height !== mapCanvas.height) {
      setSize(
        mapCanvas.clientWidth,
        mapCanvas.clientHeight,
        true,
        mapCanvas.offsetTop,
        mapCanvas.offsetLeft
      );
    }
    const pVMx = "defaultProjectionData" in viewProjMx ? Object.values(viewProjMx.defaultProjectionData.mainMatrix) : viewProjMx;
    r3m.viewProjMx = pVMx;
    if (!ready.current && onReady) {
      ready.current = true;
      onReady();
    }
    advance(Date.now() * 1e-3, true);
  });
  (0, import_react7.useEffect)(() => {
    setOnRender && setOnRender(() => onRender);
  }, [setOnRender, onRender]);
  (0, import_react7.useLayoutEffect)(() => {
    if (!manualRender)
      return;
    set({ camera: camRef.current });
  }, []);
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: manualRender && (0, import_jsx_runtime3.jsx)(
    "perspectiveCamera",
    {
      ref: camRef,
      matrixAutoUpdate: false,
      matrixWorldAutoUpdate: false
    }
  ) });
});
SyncCameraFC.displayName = "SyncCameraFC";

// node_modules/react-three-map/dist/maplibre/es/main18.mjs
var CanvasPortal = (0, import_react8.memo)(({
  children,
  latitude,
  longitude,
  altitude,
  setOnRender,
  map,
  fromLngLat: fromLngLat2,
  ...props
}) => {
  const mapCanvas = map.getCanvas();
  const eventSource = mapCanvas.parentElement;
  const [ready, setReady] = (0, import_react8.useState)(false);
  const onReady = useFunction(() => {
    setReady(true);
  });
  return (0, import_jsx_runtime4.jsxs)(
    Canvas,
    {
      events,
      eventSource,
      ...props,
      gl: { autoClear: false, ...props.gl },
      children: [
        (0, import_jsx_runtime4.jsx)(
          InitR3M,
          {
            map,
            fromLngLat: fromLngLat2,
            latitude,
            longitude,
            altitude
          }
        ),
        (0, import_jsx_runtime4.jsx)(
          SyncCameraFC,
          {
            latitude,
            longitude,
            altitude,
            setOnRender,
            onReady,
            map
          }
        ),
        ready && children
      ]
    }
  );
});
CanvasPortal.displayName = "CanvasPortal";

// node_modules/react-three-map/dist/maplibre/es/main9.mjs
var InitCanvasFC = (0, import_react9.memo)((props) => {
  const canvas = props.map.getCanvas();
  const [el] = (0, import_react9.useState)(() => {
    const el2 = document.createElement("div");
    el2.style.position = "absolute";
    el2.style.top = "0";
    el2.style.bottom = "0";
    el2.style.left = "0";
    el2.style.right = "0";
    el2.style.pointerEvents = "none";
    return el2;
  });
  (0, import_react9.useEffect)(() => {
    const parent = canvas.parentElement;
    parent.appendChild(el);
    return () => {
      parent.removeChild(el);
    };
  }, []);
  return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: (0, import_react_dom.createPortal)((0, import_jsx_runtime5.jsx)(CanvasPortal, { ...props }), el) });
});
InitCanvasFC.displayName = "InitCanvasFC";

// node_modules/react-three-map/dist/maplibre/es/main3.mjs
extend(three_module_exports);
var fromLngLat = import_maplibre_gl.MercatorCoordinate.fromLngLat;
var Canvas2 = (0, import_react10.memo)(({ overlay, ...props }) => {
  const map = useMap().current.getMap();
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
    overlay && (0, import_jsx_runtime6.jsx)(CanvasOverlay, { map, ...props }),
    !overlay && (0, import_jsx_runtime6.jsx)(CanvasInLayer, { map, ...props })
  ] });
});
Canvas2.displayName = "Canvas";
var CanvasInLayer = (0, import_react10.memo)(({ map, ...props }) => {
  const layerProps = useCanvasInLayer(props, fromLngLat, map);
  return (0, import_jsx_runtime6.jsx)(Layer, { ...layerProps });
});
CanvasInLayer.displayName = "CanvasInLayer";
var CanvasOverlay = (0, import_react10.memo)(({ map, id, beforeId, ...props }) => {
  const [onRender, setOnRender] = (0, import_react10.useState)();
  const render = useFunction((_gl, mx) => {
    if (!onRender)
      return;
    onRender(mx);
  });
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
    (0, import_jsx_runtime6.jsx)(Layer, { id, beforeId, type: "custom", render }),
    (0, import_jsx_runtime6.jsx)(
      InitCanvasFC,
      {
        ...props,
        setOnRender,
        map,
        fromLngLat
      }
    )
  ] });
});
CanvasInLayer.displayName = "CanvasInLayer";

// node_modules/react-three-map/dist/maplibre/es/main4.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var Coordinates = (0, import_react11.memo)(({
  latitude,
  longitude,
  altitude = 0,
  children
}) => {
  const [scene] = (0, import_react11.useState)(() => new Scene());
  const r3m = useR3M();
  const origin = useCoordsToMatrix({
    latitude,
    longitude,
    altitude,
    fromLngLat: r3m.fromLngLat
  });
  return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: createPortal((0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
    (0, import_jsx_runtime7.jsx)(RenderAtCoords, { r3m, origin }),
    children
  ] }), scene, { events: { priority: 2 } }) });
});
Coordinates.displayName = "Coordinates";
function RenderAtCoords({ r3m, origin }) {
  const { gl, scene, set } = useThree();
  const cameraRef = (0, import_react11.useRef)(null);
  useFrame(() => {
    if (!cameraRef.current)
      return;
    syncCamera(cameraRef.current, origin, r3m.viewProjMx);
    gl.render(scene, cameraRef.current);
  });
  (0, import_react11.useLayoutEffect)(() => {
    if (!cameraRef.current)
      return;
    set({
      invalidate: () => {
        if (!r3m.map)
          return;
        r3m.map.triggerRepaint();
      },
      camera: cameraRef.current
    });
  }, [set, r3m]);
  return (0, import_jsx_runtime7.jsx)("perspectiveCamera", { ref: cameraRef });
}

// node_modules/react-three-map/dist/maplibre/es/main14.mjs
var earthRadius = 63710088e-1;

// node_modules/react-three-map/dist/maplibre/es/main5.mjs
var mercatorScaleLookup = {};
function getMercatorScale(lat) {
  const index = Math.round(lat * 1e3);
  if (mercatorScaleLookup[index] === void 0) {
    mercatorScaleLookup[index] = 1 / Math.cos(lat * MathUtils.DEG2RAD);
  }
  return mercatorScaleLookup[index];
}
function averageMercatorScale(originLat, pointLat, steps = 10) {
  let totalScale = 0;
  const latStep = (pointLat - originLat) / steps;
  for (let i = 0; i <= steps; i++) {
    const lat = originLat + latStep * i;
    totalScale += getMercatorScale(lat);
  }
  return totalScale / (steps + 1);
}
function coordsToVector3(point, origin) {
  const latitudeDiff = (point.latitude - origin.latitude) * MathUtils.DEG2RAD;
  const longitudeDiff = (point.longitude - origin.longitude) * MathUtils.DEG2RAD;
  const altitudeDiff = (point.altitude || 0) - (origin.altitude || 0);
  const x = longitudeDiff * earthRadius * Math.cos(origin.latitude * MathUtils.DEG2RAD);
  const y = altitudeDiff;
  const steps = Math.ceil(Math.abs(point.latitude - origin.latitude)) * 100 + 1;
  const avgScale = averageMercatorScale(origin.latitude, point.latitude, steps);
  const z = -latitudeDiff * earthRadius / getMercatorScale(origin.latitude) * avgScale;
  return [x, y, z];
}

// node_modules/react-three-map/dist/maplibre/es/main6.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var NearCoordinates = (0, import_react12.memo)(({ children, ...coords }) => {
  const { latitude, longitude, altitude } = useCoords();
  const pos2 = (0, import_react12.useMemo)(() => coordsToVector3(coords, { latitude, longitude, altitude }), [
    // eslint-disable-line react-hooks/exhaustive-deps
    latitude,
    longitude,
    altitude,
    coords.latitude,
    coords.longitude,
    coords.altitude
  ]);
  return (0, import_jsx_runtime8.jsx)("object3D", { position: pos2, children });
});
NearCoordinates.displayName = "NearCoordinates";

// node_modules/react-three-map/dist/maplibre/es/main7.mjs
function vector3ToCoords(position, origin) {
  const [x, y, z] = position;
  const latitude = origin.latitude + -z / earthRadius * MathUtils.RAD2DEG;
  const longitude = origin.longitude + x / earthRadius * MathUtils.RAD2DEG / Math.cos(origin.latitude * MathUtils.DEG2RAD);
  const altitude = (origin.altitude || 0) + y;
  const coords = { latitude, longitude, altitude };
  return coords;
}

// node_modules/react-three-map/dist/maplibre/es/main.mjs
var useMap3 = useMap2;
export {
  Canvas2 as Canvas,
  Coordinates,
  NearCoordinates,
  averageMercatorScale,
  coordsToVector3,
  useMap3 as useMap,
  vector3ToCoords
};
//# sourceMappingURL=react-three-map_maplibre.js.map
