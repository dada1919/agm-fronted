import {
  Group,
  Matrix4,
  PerspectiveCamera,
  Scene,
  Vector3,
  WebGLRenderer
} from "./chunk-I64PBAE6.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@dvgis/maplibre-three-plugin/dist/index.js
var o = 63710088e-1;
var u = 2 * Math.PI * o;
var s = Math.PI / 180;
var z = 180 / Math.PI;
var h = 1024e3 / u;
var S = 512;
var w = class {
  static clamp(t, e, a) {
    return Math.min(a, Math.max(e, t));
  }
  static makePerspectiveMatrix(t, e, a, r) {
    let p = 1 / Math.tan(t / 2), m = 1 / (a - r);
    return [p / e, 0, 0, 0, 0, p, 0, 0, 0, 0, (r + a) * m, -1, 0, 0, 2 * r * a * m, 0];
  }
  static mercatorXFromLng(t) {
    return (180 + t) / 360;
  }
  static mercatorYFromLat(t) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;
  }
};
var l = w;
var g = new Matrix4();
var D = new Matrix4();
var L = 85.051129;
var M = class {
  constructor(t) {
    this._map = t.map, this._world = t.world, this._camera = t.camera, this._translateCenter = new Matrix4().makeTranslation(1024e3 / 2, -1024e3 / 2, 0), this._worldSizeRatio = S / 1024e3, this._map.on("move", this.syncCamera.bind(this)), this._map.on("resize", this.syncCamera.bind(this));
  }
  syncCamera() {
    let t = this._map.transform;
    this._camera.aspect = t.width / t.height;
    let e = t.centerOffset || new Vector3(), a = t.fov * s, r = t.pitch * s, p = t.bearing * s;
    g.elements = l.makePerspectiveMatrix(a, this._camera.aspect, t.height / 50, t.farZ), this._camera.projectionMatrix = g, this._camera.projectionMatrix.elements[8] = -e.x * 2 / t.width, this._camera.projectionMatrix.elements[9] = e.y * 2 / t.height, D.makeTranslation(0, 0, t.cameraToCenterDistance);
    let m = new Matrix4().premultiply(D).premultiply(new Matrix4().makeRotationX(r)).premultiply(new Matrix4().makeRotationZ(-p));
    t.elevation && (m.elements[14] = t.cameraToCenterDistance * Math.cos(r)), this._camera.matrixWorld.copy(m);
    let _ = t.scale * this._worldSizeRatio, T = new Matrix4().makeScale(_, _, _), d = t.x, f = t.y;
    if (!d || !f) {
      let y = t.center, A = l.clamp(y.lat, -L, L);
      d = l.mercatorXFromLng(y.lng) * t.worldSize, f = l.mercatorYFromLat(A) * t.worldSize;
    }
    let v = new Matrix4().makeTranslation(-d, f, 0), C = new Matrix4().makeRotationZ(Math.PI);
    this._world.matrix = new Matrix4().premultiply(C).premultiply(this._translateCenter).premultiply(T).premultiply(v);
  }
};
var P = M;
var b = { scene: null, camera: null, renderer: null, preserveDrawingBuffer: false, renderLoop: (i) => {
  i.renderer.resetState(), i.renderer.render(i.scene, i.camera);
} };
var R = class {
  constructor(t, e = {}) {
    if (!t) throw "miss map";
    this._map = t, this._options = { ...b, ...e }, this._canvas = t.getCanvas(), this._scene = this._options.scene || new Scene(), this._camera = this._options.camera || new PerspectiveCamera(this._map.transform.fov, this._map.transform.width / this._map.transform.height, 0.1, 1e21), this._camera.matrixAutoUpdate = false, this._renderer = this._options.renderer || new WebGLRenderer({ alpha: true, antialias: true, preserveDrawingBuffer: this._options.preserveDrawingBuffer, canvas: this._canvas, context: this._canvas.getContext("webgl2") }), this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.setSize(this._canvas.clientWidth, this._canvas.clientHeight), this._renderer.autoClear = false, this._world = new Group(), this._world.name = "world", this._world.position.set(1024e3 / 2, 1024e3 / 2, 0), this._world.matrixAutoUpdate = false, this._scene.add(this._world), this._cameraSync = void 0, this._map.on("style.load", this._onStyleLoad.bind(this));
  }
  get map() {
    return this._map;
  }
  get canvas() {
    return this._canvas;
  }
  get camera() {
    return this._camera;
  }
  get scene() {
    return this._scene;
  }
  get world() {
    return this._world;
  }
  get renderer() {
    return this._renderer;
  }
  _onStyleLoad() {
    let t = this;
    this._map.addLayer({ id: "map_scene_layer", type: "custom", renderingMode: "3d", onAdd: function(e, a) {
      t._cameraSync || (this._cameraSync = new P(t), this._cameraSync.syncCamera());
    }, render: function(e, a) {
      t.render();
    } });
  }
  render() {
    return this._options.renderLoop(this), this;
  }
};
var I = R;
var x = class {
  static projectedUnitsPerMeter(t) {
    return Math.abs(1024e3 / Math.cos(s * t) / u);
  }
  static lngLatToVector3(t, e, a = 0) {
    let r = [0, 0, 0];
    return Array.isArray(t) ? (r = [-o * s * t[0] * h, -o * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * s * t[1])) * h], t[2] ? r.push(t[2] * this.projectedUnitsPerMeter(t[1])) : r.push(0)) : (r = [-o * s * t * h, -o * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * s * e)) * h], a ? r.push(a * this.projectedUnitsPerMeter(e)) : r.push(0)), new Vector3(r[0], r[1], r[2]);
  }
  static vector3ToLngLat(t) {
    let e = { lng: 0, lat: 0, alt: 0 };
    return t && (e.lng = -t.x / (o * s * h), e.lat = 2 * (Math.atan(Math.exp(t.y / (h * -o))) - Math.PI / 4) / s, e.alt = t.z / this.projectedUnitsPerMeter(e.lat)), e;
  }
};
var E = x;
window.THREE && (window.MapScene = I, window.SceneTransform = E);
export {
  I as MapScene,
  E as SceneTransform
};
//# sourceMappingURL=@dvgis_maplibre-three-plugin.js.map
