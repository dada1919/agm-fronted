import { jsx, Fragment } from "react/jsx-runtime";
import { useThree, useFrame } from "@react-three/fiber";
import { memo, useRef, useMemo, useEffect, useLayoutEffect } from "react";
import { syncCamera } from "./main11.mjs";
import { useCoordsToMatrix } from "./main12.mjs";
import { useFunction } from "./main10.mjs";
import { useR3M } from "./main13.mjs";
const SyncCameraFC = memo(({
  latitude,
  longitude,
  altitude = 0,
  setOnRender,
  manualRender,
  onReady,
  map
}) => {
  const mapCanvas = map.getCanvas();
  const r3m = useR3M();
  const camRef = useRef(null);
  const camera = useThree((s) => s.camera);
  const gl = useThree((s) => s.gl);
  const threeCanvas = useThree((s) => s.gl.domElement);
  const scene = useThree((s) => s.scene);
  const advance = useThree((s) => s.advance);
  const setSize = useThree((s) => s.setSize);
  const set = useThree((s) => s.set);
  const origin = useCoordsToMatrix({ latitude, longitude, altitude, fromLngLat: r3m.fromLngLat });
  const ready = useRef(false);
  const triggerRepaint = useMemo(() => map.triggerRepaint, [map]);
  const mapPaintRequests = useRef(0);
  const triggerRepaintOff = useFunction(() => {
    mapPaintRequests.current++;
  });
  useFrame(() => {
    syncCamera(camera, origin, r3m.viewProjMx);
    if (manualRender)
      gl.render(scene, camera);
    map.triggerRepaint = triggerRepaint;
    if (mapPaintRequests.current > 0) {
      mapPaintRequests.current = 0;
      map.triggerRepaint();
    }
  }, -Infinity);
  const onRender = useFunction((viewProjMx) => {
    map.triggerRepaint = triggerRepaintOff;
    if (threeCanvas.width !== mapCanvas.width || threeCanvas.height !== mapCanvas.height) {
      setSize(
        mapCanvas.clientWidth,
        mapCanvas.clientHeight,
        true,
        mapCanvas.offsetTop,
        mapCanvas.offsetLeft
      );
    }
    const pVMx = "defaultProjectionData" in viewProjMx ? Object.values(viewProjMx.defaultProjectionData.mainMatrix) : viewProjMx;
    r3m.viewProjMx = pVMx;
    if (!ready.current && onReady) {
      ready.current = true;
      onReady();
    }
    advance(Date.now() * 1e-3, true);
  });
  useEffect(() => {
    setOnRender && setOnRender(() => onRender);
  }, [setOnRender, onRender]);
  useLayoutEffect(() => {
    if (!manualRender)
      return;
    set({ camera: camRef.current });
  }, []);
  return /* @__PURE__ */ jsx(Fragment, { children: manualRender && /* @__PURE__ */ jsx(
    "perspectiveCamera",
    {
      ref: camRef,
      matrixAutoUpdate: false,
      matrixWorldAutoUpdate: false
    }
  ) });
});
SyncCameraFC.displayName = "SyncCameraFC";
export {
  SyncCameraFC
};
//# sourceMappingURL=main22.mjs.map
